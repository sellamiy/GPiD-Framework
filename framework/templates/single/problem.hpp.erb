/**
 * \file gpid/solver-interfaces/<%= @solver.name %>_problem.hpp
 * \brief <%= @solver.name %> Problem classes definitions.
 * \author Yanis Sellami
 * \date 2017
 */
#ifndef GPID_<%= @solver.name %>_PROBLEM_HPP
#define GPID_<%= @solver.name %>_PROBLEM_HPP

#include <memory>
#include <gpid/solver-interfaces/<%= @solver.name %>_context.hpp>

namespace gpid {

    class <%= @solver.problemClass %>Internal;

    /**
     * \brief Problem class for <%= @solver.name %> solver interface.
     * \ingroup gpid<%= @solver.name %>lib
     */
    class <%= @solver.problemClass %> {
    public:
        /** \brief Enum form problem generation mode */
        enum IOMode { IO_READ, IO_WRITE };
        /** \brief Context manager type handled by the problem */
        typedef <%= @solver.contextManagerClass %> ContextManagerT;
        /** \brief Declarations type handled by the problem */
        typedef <%= @solver.declarationsClass %> DeclarationsT;
    private:
        IOMode mode = IOMode::IO_WRITE;
        typedef <%= @solver.problemClass %>Internal Internal;
        std::unique_ptr<Internal> handler;

        ContextManagerT& ctx;
        DeclarationsT decls;

        void initCurrentMode();
    public:
        <%= @solver.problemClass %>(ContextManagerT& ctx);
        ~<%= @solver.problemClass %>();

        inline void setMode(IOMode nmode) { mode = nmode; initCurrentMode(); }
        inline ContextManagerT& getContextManager() { return ctx; }
        inline DeclarationsT& getDeclarations() { return decls; }
        void addConstraint(<%= @solver.problemConstraintType %> cons);
        bool hasMoreConstraints();
        <%= @solver.problemConstraintType %> nextConstraint();
    };

};

#endif
