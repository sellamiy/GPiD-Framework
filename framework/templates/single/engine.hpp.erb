/**
 * \file gpid/solver-interfaces/<%= @solver.name %>_engine.hpp
 * \brief <%= @solver.name %> Solver Interface Classes.
 * \author Yanis Sellami
 * \date 2017
 */
#ifndef GPID_<%= @solver.name %>_ENGINE_INTERFACE_HPP
#define GPID_<%= @solver.name %>_ENGINE_INTERFACE_HPP

#include <gpid/core/engine.hpp>
#include <gpid/solver-interfaces/<%= @solver.name %>_problem.hpp>

namespace gpid {

    class <%= @solver.solverClass %>Internal;

    /**
     * \brief Solver Interface for <%= @solver.name %> solver.
     * \ingroup gpid<%= @solver.name %>lib
     */
    class <%= @solver.solverClass %> {
    public:
        /** \brief Hypothesis type handled by the solver */
        typedef <%= @solver.hypothesisClass %> HypothesisT;
        /** \brief Model type handled by the solver */
        typedef <%= @solver.modelClass %> ModelT;
        /** \brief Problem type handled by the solver */
        typedef <%= @solver.problemClass %> ProblemT;
        /** \brief Context manager type handled by the solver */
        typedef <%= @solver.contextManagerClass %> ContextManagerT;
        /** \brief Declarations type handled by the solver */
        typedef <%= @solver.declarationsClass %> DeclarationsT;
    private:
        ContextManagerT ctx;
        typedef <%= @solver.solverClass %>Internal Internal;
        std::unique_ptr<Internal> solvers;

        uint32_t c_level;

        void accessLevel(uint32_t level);
    public:

        /** \brief Display basic information on the solver used */
        inline void printSolverInformations()
        { snlog::l_info("Interface for <%= @solver.name %>"); }

        /** \brief Remove all the hypotheses assigned after a given level */
        void removeHypotheses(uint32_t level);
        /** \brief Add an abducible hypothesis to the solver */
        void addHypothesis(HypothesisT& hypothesis, uint32_t level);
        /** \brief Check if the current set of hypotheses is compatible with the problem */
        gpid::SolverTestStatus testHypotheses(uint32_t level);
        /** \brief Check if the current set of hypotheses is self-consistent */
        gpid::SolverTestStatus checkConsistency(uint32_t level);
        /** \brief Check if an hypothesis is known to be redundant */
        bool storageSubsumed(HypothesisT& additional, uint32_t level);

        ModelT& recoverModel();
        inline ContextManagerT& getContextManager() { return ctx; }

        /** \brief Print the negation of the current set of hypotheses */
        void printActiveNegation();
        /** \brief Remember the current set of hypotheses as an implicate */
        void storeActive();

        <%= @solver.solverClass %>();
        ~<%= @solver.solverClass %>();
        void setProblem(ProblemT& problem);
        void start();
    };

};

#endif
