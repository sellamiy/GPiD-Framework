#define GPID_<%= @solver.name %>_ABDUCIBLE_WRAPPERS_CPP

#include <gpid/util/parsers.hpp>
#include <gpid/util/generators.hpp>
#include <gpid/solver-interfaces/<%= @solver.name %>_inputs.hpp>

<% for @snippet in @solver.abducibleSnippets %>
#include <gpid/solver-snippets/<%= @solver.name %>/<%= @snippet %>>
<% end %>

using namespace snlog;

namespace gpid {

    enum <%= @solver.name %>InputGenerator {
        <% for @generator in @solver.abducibleGenerators %>
        <%= @solver.name %>_IG_<%= @generator["name"] %>,
        <% end %>
        <%= @solver.name %>_IG_NONE
    };

    static inline <%= @solver.name %>InputGenerator to<%= @solver.name %>InputGenerator(std::string key) {
        <% for @generator in @solver.abducibleGenerators %>
        if (key == "<%= @generator["name"] %>") {
            return <%= @solver.name %>_IG_<%= @generator["name"] %>;
        }
        <% end %>
        l_error("Unknown <%= @solver.name %> abducible generator: " + key);
        <% for @generator in @solver.abducibleGenerators %>
        l_info("   -- available: <%= @generator["name"] %>");
        <% end %>
        throw UnknownUtilityError("abducible generator");
    }

    <% if @solver.abducibleGenerators.empty? %>
    static inline uint32_t <%= @solver.name %>AbducibleCompt
    (<%= @solver.name %>InputGenerator, <%= @solver.problemClass %>&) {
        throw UnknownUtilityError("No abducible generator available for solver <%= @solver.name %>");
    }
    <% else %>
    static inline uint32_t <%= @solver.name %>AbducibleCompt
    (<%= @solver.name %>InputGenerator g, <%= @solver.problemClass %>& pbl) {
        switch (g) {
        <% for @generator in @solver.abducibleGenerators %>
        case <%= @solver.name %>_IG_<%= @generator["name"] %>:
            return <%= @generator["counter"] %>(pbl.getContextManager(), pbl.getDeclarations());
        <% end %>
        default:
            throw InternalError("Unknown <%= @solver.name %> abducible generator: " + std::to_string(g));
        }
    }
    <% end %>

    struct <%= @solver.name %>GeneratorCounter {
        inline uint32_t operator() (std::string gkey, <%= @solver.problemClass %>& pbl)
        { return <%= @solver.name %>AbducibleCompt(to<%= @solver.name %>InputGenerator(gkey), pbl); }
    };

    struct <%= @solver.name %>Loader {
        inline void operator()
        (int idx, const std::string expr,
         <%= @solver.contextManagerClass %>& ctx, <%= @solver.declarationsClass %>& decls,
         LiteralsEngine<<%= @solver.solverClass %>Engine>& set, std::map<int,int>& linker)
        { <%= @solver.abducibleLoader %>(idx, expr, ctx, decls, set, linker); }
    };

    <% if @solver.abducibleGenerators.empty? %>
    static inline void <%= @solver.name %>AbducibleGen
    (<%= @solver.name %>InputGenerator,
     <%= @solver.contextManagerClass %>&,
     <%= @solver.declarationsClass %>&,
     LiteralsEngine<<%= @solver.solverClass %>Engine>&) {
        throw UnknownUtilityError("No abducible generator available for solver <%= @solver.name %>");
    }
    <% else %>
    static inline void <%= @solver.name %>AbducibleGen
    (<%= @solver.name %>InputGenerator g,
     <%= @solver.contextManagerClass %>& ctx,
     <%= @solver.declarationsClass %>& decls,
     LiteralsEngine<<%= @solver.solverClass %>Engine>& set) {
        switch (g) {
        <% for @generator in @solver.abducibleGenerators %>
        case <%= @solver.name %>_IG_<%= @generator["name"] %>:
            <%= @generator["generator"] %>(ctx, decls, set);
            break;
        <% end %>
        default:
            throw InternalError("Unknown <%= @solver.name %> abducible generator: " + std::to_string(g));
        }
    }
    <% end %>

    struct <%= @solver.name %>Generator {
        inline void operator()
        (std::string gkey,
         <%= @solver.contextManagerClass %>& ctx,
         <%= @solver.declarationsClass %>& decls,
         LiteralsEngine<<%= @solver.solverClass %>Engine>& set)
        { <%= @solver.name %>AbducibleGen(to<%= @solver.name %>InputGenerator(gkey), ctx, decls, set); }
    };

    extern uint32_t countAbducibles(AbduciblesOptions& opts, <%= @solver.problemClass %>& pbl) {
        return countAbducibles<<%= @solver.problemClass %>, <%= @solver.name %>GeneratorCounter>(opts, pbl);
    }

    extern void generateAbducibles
    (AbduciblesOptions& opts,
     <%= @solver.contextManagerClass %>& ctx,
     <%= @solver.declarationsClass %>& decls,
     LiteralsEngine<<%= @solver.solverClass %>Engine>& set) {
        generateAbducibles<<%= @solver.problemClass %>,
                           LiteralsEngine<<%= @solver.solverClass %>Engine>,
                           <%= @solver.name %>Generator, <%= @solver.name %>Loader>
            (opts, ctx, decls, set);
    }

}
