#ifndef GTS_EXECUTORS_SNIPPET
#define GTS_EXECUTORS_SNIPPET

#ifdef SINGLE_SOLVER_ONLY
<% for @solver in @solvers %>
#ifdef SINGLE_SOLVER_<%= @solver.name %>
#include <gpid/solvers/<%= @solver.name %>_interface.hpp>
template void generate<<%= @solver.solverClass %>Engine>(OptionStorage& opts);
static inline gtsExecutionStatus wrap_generate(OptionStorage& opts) {
    try {
        generate<<%= @solver.solverClass %>Engine>(opts);
        return gtsExecutionStatus::SUCCESS;
    }

  <% for @except in @solver.solverExceptions %>
    catch (<%= @except["name"] %>& e) {
        snlog::l_fatal("Solver exception recovered");
        snlog::l_error(e.<%= @except["messager"] %>());
        return gtsExecutionStatus::FAILURE;
    }
  <% end %>
    catch (gpid::InternalError& e) {
        snlog::l_internal(e.what());
        return gtsExecutionStatus::FAILURE;
    }
    catch (gpid::GPiDError& e) {
        snlog::l_fatal(e.what());
        return gtsExecutionStatus::FAILURE;
    }
    catch (std::exception& e) {
        snlog::l_internal("Unexpected throwable recovered");
        snlog::l_fatal(e.what());
        return gtsExecutionStatus::FAILURE;
    }
}
#endif
<% end %>
#else
#include <gpid/solvers/all.hpp>
<% for @solver in @solvers %>
template void generate<<%= @solver.solverClass %>Engine>(OptionStorage& opts);
<% end %>
static inline gtsExecutionStatus wrap_generate(OptionStorage& opts) {
    switch (opts.generator) {
    <% for @solver in @solvers %>
    case EngineSelection::<%= @solver.name %>_INTERFACE:
        try {
            generate<<%= @solver.solverClass %>Engine>(opts);
            return gtsExecutionStatus::SUCCESS;
        }

      <% for @except in @solver.solverExceptions %>
        catch (<%= @except["name"] %>& e) {
            snlog::l_fatal("Solver <%= @solver.name %> exception recovered");
            snlog::l_error(e.<%= @except["messager"] %>());
            return gtsExecutionStatus::FAILURE;
        }
      <% end %>
        catch (gpid::InternalError& e) {
            snlog::l_internal(e.what());
            return gtsExecutionStatus::FAILURE;
        }
        catch (gpid::GPiDError& e) {
            snlog::l_fatal(e.what());
            return gtsExecutionStatus::FAILURE;
        }
        catch (std::exception& e) {
            snlog::l_internal("Unexpected throwable recovered");
            snlog::l_fatal(e.what());
            return gtsExecutionStatus::FAILURE;
        }
    <% end %>
    default:
        snlog::l_internal("Asked for unknown gts generator");
        return gtsExecutionStatus::FAILURE;
    }
}
#endif

#endif
