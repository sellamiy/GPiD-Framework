#define GPID_<%= @solver.name %>_ABDUCIBLE_WRAPPERS_CPP

#include <gpid/util/parsers.hpp>
#include <gpid/util/generators.hpp>
#include <gpid/solver-interfaces/<%= @solver.name %>_inputs.hpp>

<% for @snippet in @solver.abducibleSnippets %>
#include <gpid/solver-snippets/<%= @solver.name %>/<%= @snippet %>>
<% end %>

using namespace snlog;

namespace gpid {

    enum <%= @solver.name %>InputGenerator {
        <% for @generator in @solver.abducibleGenerators %>
        <%= @solver.name %>_IG_<%= @generator["name"] %>,
        <% end %>
        <%= @solver.name %>_IG_NONE
    };

    static inline <%= @solver.name %>InputGenerator to<%= @solver.name %>InputGenerator(std::string key) {
        <% for @generator in @solver.abducibleGenerators %>
        if (key == "<%= @generator["name"] %>") {
            return <%= @solver.name %>_IG_<%= @generator["name"] %>;
        }
        <% end %>
        l_error("Unknown <%= @solver.name %> abducible generator: " + key);
        <% for @generator in @solver.abducibleGenerators %>
        l_info("   -- available: <%= @generator["name"] %>");
        <% end %>
        throw UnknownUtilityError("abducible generator");
    }

    <% if @solver.abducibleGenerators.empty? %>
    static inline uint32_t <%= @solver.name %>AbducibleCompt
    (<%= @solver.name %>InputGenerator, <%= @solver.problemClass %>&) {
        throw UnknownUtilityError("No abducible generator available for solver <%= @solver.name %>");
    }
    <% else %>
    static inline uint32_t <%= @solver.name %>AbducibleCompt
    (<%= @solver.name %>InputGenerator g, <%= @solver.problemClass %>& pbl) {
        switch (g) {
        <% for @generator in @solver.abducibleGenerators %>
        case <%= @solver.name %>_IG_<%= @generator["name"] %>:
            return <%= @generator["counter"] %>(pbl.getContextManager(), pbl.getDeclarations());
        <% end %>
        default:
            throw InternalError("Unknown <%= @solver.name %> abducible generator: " + std::to_string(g));
        }
    }
    <% end %>

    struct <%= @solver.name %>GeneratorCounter {
        inline uint32_t operator() (std::string gkey, <%= @solver.problemClass %>& pbl)
        { return <%= @solver.name %>AbducibleCompt(to<%= @solver.name %>InputGenerator(gkey), pbl); }
    };

    static inline void loadAbducibles
    (std::string filename,
     <%= @solver.contextManagerClass %>& ctx,
     <%= @solver.declarationsClass %>& decls,
     HypothesesSet<<%= @solver.solverClass %>>& set) {
        alloc_gab<<%= @solver.solverClass %>::HypothesisT>(set.getSourceSize());
        std::map<int, int> linker;

        AbducibleParser parser(filename);
        parser.init();
        for (uint32_t i = 0; i < set.getSourceSize(); i++) {
            if (!parser.isOk()) {
                throw ParseError("Error loading from @file:" + filename);
            }
            handleAbducible(i, parser.nextAbducible(), ctx, decls, set, linker);
        }
    }

    struct <%= @solver.name %>Loader {
        inline void operator()
        (std::string filename,
         <%= @solver.contextManagerClass %>& ctx,
         <%= @solver.declarationsClass %>& decls,
         HypothesesSet<<%= @solver.solverClass %>>& set)
        { loadAbducibles(filename, ctx, decls, set); }
    };

    <% if @solver.abducibleGenerators.empty? %>
    static inline void <%= @solver.name %>AbducibleGen
    (<%= @solver.name %>InputGenerator,
     <%= @solver.contextManagerClass %>&,
     <%= @solver.declarationsClass %>&,
     HypothesesSet<<%= @solver.solverClass %>>&) {
        throw UnknownUtilityError("No abducible generator available for solver <%= @solver.name %>");
    }
    <% else %>
    static inline void <%= @solver.name %>AbducibleGen
    (<%= @solver.name %>InputGenerator g,
     <%= @solver.contextManagerClass %>& ctx,
     <%= @solver.declarationsClass %>& decls,
     HypothesesSet<<%= @solver.solverClass %>>& set) {
        switch (g) {
        <% for @generator in @solver.abducibleGenerators %>
        case <%= @solver.name %>_IG_<%= @generator["name"] %>:
            <%= @generator["generator"] %>(ctx, decls, set);
            break;
        <% end %>
        default:
            throw InternalError("Unknown <%= @solver.name %> abducible generator: " + std::to_string(g));
        }
    }
    <% end %>

    struct <%= @solver.name %>Generator {
        inline void operator()
        (std::string gkey,
         <%= @solver.contextManagerClass %>& ctx,
         <%= @solver.declarationsClass %>& decls,
         HypothesesSet<<%= @solver.solverClass %>>& set)
        { <%= @solver.name %>AbducibleGen(to<%= @solver.name %>InputGenerator(gkey), ctx, decls, set); }
    };

    extern uint32_t countAbducibles(AbduciblesOptions& opts, <%= @solver.problemClass %>& pbl) {
        return countAbducibles<<%= @solver.problemClass %>, <%= @solver.name %>GeneratorCounter>(opts, pbl);
    }

    extern void generateAbducibles
    (AbduciblesOptions& opts,
     <%= @solver.contextManagerClass %>& ctx,
     <%= @solver.declarationsClass %>& decls,
     HypothesesSet<<%= @solver.solverClass %>>& set) {
        generateAbducibles<HypothesesSet<<%= @solver.solverClass %>>,
                           <%= @solver.contextManagerClass %>,
                           <%= @solver.declarationsClass %>,
                           <%= @solver.name %>Loader, <%= @solver.name %>Generator>
            (opts, ctx, decls, set);
    }

}
