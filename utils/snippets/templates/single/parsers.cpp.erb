#define GPID_<%= @solver.name %>_PARSERS_CPP

#include <gpid/solver-interfaces/<%= @solver.name %>_inputs.hpp>

<% for @parser_src in @solver.parserSnippets %>
#include <gpid/solver-snippets/<%= @solver.name %>/<%= @parser_src %>>
<% end %>

namespace gpid {

    <% if @solver.parsers.empty? %>
    extern void parse_file(std::string, <%= @solver.contextManagerClass %>&,
                           <%= @solver.problemClass %>&, std::string) {
        snlog::l_fatal("No parser available for solver <%= @solver.name %>");
    }
    <% else %>
    extern void parse_file(std::string filename, <%= @solver.contextManagerClass %>& ctx,
                           <%= @solver.problemClass %>& pbl, std::string language) {
        <% for @parser in @solver.parsers %>
        if (language == "<%= @parser["language"] %>") {
            <%= @parser["function"] %>(filename, ctx, pbl);
            return;
        }
        <% end %>
        if (language == "default") {
          <% if ! @solver.parsers.empty? %>
            <%= @solver.parsers[0]["function"] %>(filename, ctx, pbl);
          <% else %>
            snlog::l_fatal("No default parser for solver <%= @solver.name %>");
          <% end %>
        } else {
            snlog::l_fatal("Unknown input language for solver <%= @solver.name %>: " + language);
            <% for @parser in @solver.parsers %>
            snlog::l_info("   -- available: <%= @parser["language"] %>");
            <% end %>
        }
    }
    <% end %>

}
